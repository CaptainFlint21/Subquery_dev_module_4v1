"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const url_1 = require("url");
const command_1 = require("@oclif/command");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const cli_ux_1 = (0, tslib_1.__importDefault)(require("cli-ux"));
const fuzzy_1 = (0, tslib_1.__importDefault)(require("fuzzy"));
const inquirer = (0, tslib_1.__importStar)(require("inquirer"));
const lodash_1 = require("lodash");
const init_controller_1 = require("../controller/init-controller");
const jsonrpc_1 = require("../jsonrpc");
inquirer.registerPrompt('autocomplete', require('inquirer-autocomplete-prompt'));
// Helper function for fuzzy search on prompt input
function filterInput(arr) {
    return (_, input) => {
        input = input || '';
        return new Promise((resolve) => {
            resolve(fuzzy_1.default.filter(input, arr).map((el) => {
                return el.original;
            }));
        });
    };
}
async function promptValidRemoteAndBranch() {
    let isValid = false;
    let remote;
    while (!isValid) {
        try {
            remote = await cli_ux_1.default.prompt('Custom template git remote', {
                required: true,
            });
            new url_1.URL(remote);
            isValid = true;
        }
        catch (e) {
            console.log(`Not a valid git remote URL: '${remote}', try again`);
            continue;
        }
    }
    const branch = await cli_ux_1.default.prompt('Custom template git branch', {
        required: true,
    });
    return [remote, branch];
}
class Init extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Init);
        if (flags.specVersion === '0.0.1') {
            this.log(`${chalk_1.default.yellow('WARNING')} Using specVersion v0.0.1 is deprecated and in the future will be denied from being uploaded to the subquery hosted service. Consider initializing your project with specVersion v0.2.0`);
        }
        const project = {};
        const location = flags.location ? path_1.default.resolve(flags.location) : process.cwd();
        project.name = args.projectName
            ? args.projectName
            : await cli_ux_1.default.prompt('Project name', { default: 'subql-starter', required: true });
        if (fs_1.default.existsSync(path_1.default.join(location, `${project.name}`))) {
            throw new Error(`Directory ${project.name} exists, try another project name`);
        }
        let useCustomTemplate = false;
        let gitRemote;
        let gitBranch;
        let templates;
        let selectedTemplate;
        let selectedNetwork;
        try {
            templates = await (0, init_controller_1.fetchTemplates)();
        }
        catch (e) {
            this.error(e);
        }
        templates = templates.filter(({ specVersion }) => specVersion === flags.specVersion);
        // Fallback to custom prompt if templates remote is empty
        if (templates.length === 0) {
            useCustomTemplate = true;
        }
        if (!useCustomTemplate) {
            const networks = (0, lodash_1.uniq)(templates.map(({ network }) => network));
            networks.push('Other');
            // Network selection
            await inquirer
                .prompt([
                {
                    name: 'networkResponse',
                    message: 'Select a network',
                    type: 'autocomplete',
                    searchText: '',
                    emptyText: 'Network not found',
                    source: filterInput(networks),
                },
            ])
                .then(({ networkResponse }) => {
                if (networkResponse === 'Other') {
                    useCustomTemplate = true;
                }
                else {
                    selectedNetwork = networkResponse;
                }
            });
            if (!useCustomTemplate) {
                const candidateTemplates = templates.filter(({ network }) => network === selectedNetwork);
                const paddingWidth = candidateTemplates.map(({ name }) => name.length).reduce((acc, xs) => Math.max(acc, xs)) + 5;
                const templateDisplays = candidateTemplates.map(({ description, name }) => `${name.padEnd(paddingWidth, ' ')}${chalk_1.default.gray(description)}`);
                templateDisplays.push(`${'Other'.padEnd(paddingWidth, ' ')}${chalk_1.default.gray('Enter a custom git endpoint')}`);
                // Network selection
                await inquirer
                    .prompt([
                    {
                        name: 'templateDisplay',
                        message: 'Select a template project',
                        type: 'autocomplete',
                        searchText: '',
                        emptyText: 'Template not found',
                        source: filterInput(templateDisplays),
                    },
                ])
                    .then(({ templateDisplay }) => {
                    const templateName = templateDisplay.split(' ')[0];
                    if (templateName === 'Other') {
                        useCustomTemplate = true;
                    }
                    else {
                        selectedTemplate = templates.find(({ name }) => name === templateName);
                        flags.specVersion = selectedTemplate.specVersion;
                    }
                });
                if (useCustomTemplate) {
                    [gitRemote, gitBranch] = await promptValidRemoteAndBranch();
                }
            }
            else {
                [gitRemote, gitBranch] = await promptValidRemoteAndBranch();
            }
        }
        else {
            [gitRemote, gitBranch] = await promptValidRemoteAndBranch();
        }
        let projectPath;
        cli_ux_1.default.action.start('Cloning project');
        try {
            if (selectedTemplate) {
                projectPath = await (0, init_controller_1.cloneProjectTemplate)(location, project.name, selectedTemplate);
            }
            else if (useCustomTemplate) {
                projectPath = await (0, init_controller_1.cloneProjectGit)(location, project.name, gitRemote, gitBranch);
            }
            else {
                throw new Error('Invalid initalization state, must select either a template project or provide a git remote');
            }
            cli_ux_1.default.action.stop();
        }
        catch (e) {
            cli_ux_1.default.action.stop();
            this.error(e);
        }
        const [defaultSpecVersion, defaultRepository, defaultEndpoint, defaultAuthor, defaultVersion, defaultDescription, defaultLicense,] = await (0, init_controller_1.readDefaults)(projectPath);
        // Update specVersion to template specVersion on custom template
        if (useCustomTemplate) {
            flags.specVersion = defaultSpecVersion;
        }
        project.endpoint = await cli_ux_1.default.prompt('RPC endpoint:', {
            default: defaultEndpoint !== null && defaultEndpoint !== void 0 ? defaultEndpoint : 'wss://polkadot.api.onfinality.io/public-ws',
            required: true,
        });
        project.repository = await cli_ux_1.default.prompt('Git repository', { required: false, default: defaultRepository });
        if (flags.specVersion === '0.2.0') {
            cli_ux_1.default.action.start('Fetching network genesis hash');
            project.genesisHash = await (0, jsonrpc_1.getGenesisHash)(project.endpoint);
            cli_ux_1.default.action.stop();
        }
        project.author = await cli_ux_1.default.prompt('Author', { required: true, default: defaultAuthor });
        project.description = await cli_ux_1.default.prompt('Description', {
            required: false,
            default: defaultDescription.substring(0, 40).concat('...'),
        });
        project.version = await cli_ux_1.default.prompt('Version', { required: true, default: defaultVersion });
        project.license = await cli_ux_1.default.prompt('License', { required: true, default: defaultLicense });
        cli_ux_1.default.action.start('Preparing project');
        await (0, init_controller_1.prepare)(projectPath, project);
        cli_ux_1.default.action.stop();
        if (flags['install-dependencies']) {
            cli_ux_1.default.action.start('Installing dependencies');
            (0, init_controller_1.installDependencies)(projectPath, flags.npm);
            cli_ux_1.default.action.stop();
        }
        this.log(`${project.name} is ready`);
        process.exit(0);
    }
}
exports.default = Init;
Init.description = 'Initialize a scaffold subquery project';
Init.flags = {
    force: command_1.flags.boolean({ char: 'f' }),
    location: command_1.flags.string({ char: 'l', description: 'local folder to create the project in' }),
    'install-dependencies': command_1.flags.boolean({ description: 'Install dependencies as well', default: false }),
    npm: command_1.flags.boolean({ description: 'Force using NPM instead of yarn, only works with `install-dependencies` flag' }),
    specVersion: command_1.flags.string({
        required: false,
        options: ['0.0.1', '0.2.0'],
        default: '0.2.0',
        description: 'The spec version to be used by the project',
    }),
};
Init.args = [
    {
        name: 'projectName',
        description: 'Give the starter project name',
    },
];
//# sourceMappingURL=init.js.map