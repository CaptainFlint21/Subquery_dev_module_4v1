"use strict";
// Copyright 2020-2021 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = (0, tslib_1.__importStar)(require("fs"));
const os_1 = (0, tslib_1.__importDefault)(require("os"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const init_controller_1 = require("./init-controller");
// async
const fileExists = async (file) => {
    return new Promise((resolve, reject) => {
        fs.access(file, fs.constants.F_OK, (err) => {
            err ? reject(err) : resolve(true);
        });
    });
};
async function makeTempDir() {
    const sep = path_1.default.sep;
    const tmpDir = os_1.default.tmpdir();
    const tempPath = await fs.promises.mkdtemp(`${tmpDir}${sep}`);
    return tempPath;
}
jest.setTimeout(30000);
const projectSpec = {
    name: 'mocked_starter',
    repository: '',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    specVersion: '0.2.0',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
};
describe('Cli can create project', () => {
    it('should resolve when starter project created via template', async () => {
        const tempPath = await makeTempDir();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, templates[0]);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}`))).resolves.toEqual(true);
    });
    it('should resolve when starter project created via git', async () => {
        const tempPath = await makeTempDir();
        const projectPath = await (0, init_controller_1.cloneProjectGit)(tempPath, projectSpec.name, 'https://github.com/subquery/subql-starter', 'v0.2.0');
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}`))).resolves.toEqual(true);
    });
    it('throw error if .git exists in starter project', async () => {
        const tempPath = await makeTempDir();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, templates[0]);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        await expect(fileExists(path_1.default.join(tempPath, `${projectSpec.name}/.git`))).rejects.toThrow();
    });
    it('prepare correctly applies project details', async () => {
        const tempPath = await makeTempDir();
        const templates = await (0, init_controller_1.fetchTemplates)();
        const template = templates.find(({ name, specVersion }) => name === 'subql-starter' && specVersion === '0.2.0');
        const projectPath = await (0, init_controller_1.cloneProjectTemplate)(tempPath, projectSpec.name, template);
        await (0, init_controller_1.prepare)(projectPath, projectSpec);
        const [specVersion, repository, endpoint, author, version, description, license] = await (0, init_controller_1.readDefaults)(projectPath);
        expect(projectSpec.specVersion).toEqual(specVersion);
        expect(projectSpec.repository).toEqual(repository);
        expect(projectSpec.endpoint).toEqual(endpoint);
        expect(projectSpec.author).toEqual(author);
        expect(projectSpec.version).toEqual(version);
        expect(projectSpec.description).toEqual(description);
        expect(projectSpec.license).toEqual(license);
    });
});
//# sourceMappingURL=init-controller.test.js.map